name: PR Naming Policy

on:
  pull_request:
    types: [opened, synchronize, edited]

permissions:
  pull-requests: write
  contents: read

jobs:
  suggest-naming:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Analyze PR files and suggest title
        id: analyze
        run: |
          set -euo pipefail

          PR_NUMBER=${{ github.event.pull_request.number }}
          REPO="${{ github.repository }}"
          TOKEN="${{ secrets.GITHUB_TOKEN }}"

          # Fetch PR files via REST API
          FILES_JSON=$(curl -s -H "Authorization: token $TOKEN" \
            "https://api.github.com/repos/$REPO/pulls/$PR_NUMBER/files?per_page=100")

          # Parse JSON
          added=(); modified=(); removed=()
          while IFS= read -r line; do
            path=$(echo "$line" | sed -n 's/.*"filename": *"\([^"]*\)".*/\1/p')
            status=$(echo "$line" | sed -n 's/.*"status": *"\([^"]*\)".*/\1/p')
            case "$status" in
              "added") added+=("$path") ;;
              "modified") modified+=("$path") ;;
              "removed") removed+=("$path") ;;
            esac
          done < <(echo "$FILES_JSON" | grep -o '{[^}]*"filename":.*"status":.*}')

          all_files=("${added[@]}" "${modified[@]}" "${removed[@]}")

          # Determine the most common top-level directory
          declare -A dir_count
          for f in "${all_files[@]}"; do
            top=${f%%/*}        # top-level directory
            (( dir_count["$top"]++ ))
          done

          # Pick the top-level dir with the most files
          max_count=0; best_dir=""
          for d in "${!dir_count[@]}"; do
            if (( dir_count["$d"] > max_count )); then
              max_count=${dir_count["$d"]}
              best_dir="$d"
            fi
          done

          # Find full nested directory path
          common_dir() {
            local dir="$1"
            shift
            for f in "$@"; do
              while [[ "$f" != "$dir"* && -n "$dir" ]]; do
                dir="${dir%/*}"
              done
            done
            echo "$dir"
          }
          full_dir=$(common_dir "${all_files[@]}")

          # Capitalize nested path
          cap_path() {
            local p="$1"
            local result=""
            IFS='/' read -ra parts <<< "$p"
            for part in "${parts[@]}"; do
              [[ -n "$part" ]] && part="$(tr '[:lower:]' '[:upper:]' <<< ${part:0:1})${part:1}"
              result+="$part/"
            done
            echo "${result%/}"
          }

          full_dir=$(cap_path "$full_dir")

          # Build action strings
          parts=()
          for f in "${added[@]}"; do parts+=("add ${f#"$full_dir/"}"); done
          for f in "${modified[@]}"; do parts+=("update ${f#"$full_dir/"}"); done
          for f in "${removed[@]}"; do parts+=("delete ${f#"$full_dir/"}"); done

          suggestion="${parts[*]}"

          # Summarize long titles
          if (( ${#suggestion} > 80 )); then
            summarize() {
              local arr=("$@")
              [[ ${#arr[@]} -eq 0 ]] && echo "" && return
              local common="${arr[0]}"
              for f in "${arr[@]}"; do
                while [[ "$f" != "$common"* && -n "$common" ]]; do
                  common="${common%/*}"
                done
              done
              echo "$common"
            }
            add_summary=$(summarize "${added[@]}")
            update_summary=$(summarize "${modified[@]}")
            delete_summary=$(summarize "${removed[@]}")

            short_parts=()
            [[ -n "$add_summary" ]] && short_parts+=("add $add_summary")
            [[ -n "$update_summary" ]] && short_parts+=("update $update_summary")
            [[ -n "$delete_summary" ]] && short_parts+=("delete $delete_summary")

            suggestion="${full_dir:+$full_dir: }${short_parts[*]}"
          else
            [[ -n "$full_dir" ]] && suggestion="$full_dir: $suggestion"
          fi

          [[ -z "$suggestion" ]] && suggestion="Update PR changes"

          echo "best_dir=$best_dir" >> "$GITHUB_OUTPUT"
          echo "full_dir=$full_dir" >> "$GITHUB_OUTPUT"
          echo "suggestion=$suggestion" >> "$GITHUB_OUTPUT"

      - name: Compare and update PR title
        uses: actions/github-script@v7
        id: title
        with:
          script: |
            const pr = context.payload.pull_request;
            const suggestion = `${{ steps.analyze.outputs.suggestion }}`.trim();
            const title = pr.title.trim();

            const fullDir = `${{ steps.analyze.outputs.full_dir }}`;
            const validCategories = fullDir ? fullDir.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') : "[A-Z][a-zA-Z0-9_-]+";
            const validPattern = new RegExp(`^(${validCategories}):\\s+(add|update|delete|fix|remove|change|refactor|improve)\\b`, "i");

            if (validPattern.test(title)) {
              core.info(`‚úÖ PR title "${title}" matches pattern.`);
              core.setOutput('updated', 'false');
            } else {
              core.info(`üõ†Ô∏è PR title "${title}" does not match pattern. Updating to: ${suggestion}`);
              await github.rest.pulls.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                title: suggestion
              });
              core.setOutput('updated', 'true');
            }

      - name: Post comment if title updated
        if: steps.title.outputs.updated == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            let suggestion = `${{ steps.analyze.outputs.suggestion }}`.trim();
            suggestion = suggestion.replace(/\\/g, '\\\\').replace(/`/g, '\\`').replace(/"/g, '\\"');
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: |
                `üëã Hi! The PR title was adjusted to match the repository naming scheme.

                **Suggested commit message format:**

                \`${suggestion}\`

                To update commits locally to match this message:

                \`\`\`bash
                git checkout ${pr.head.ref}
                git commit --amend -m "${suggestion}"
                git push --force-with-lease
                \`\`\`
                `
            });
